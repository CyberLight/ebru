<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Marching squares v4</title>
  <script src="./scripts/html2canvas.min.js"></script>
  <script type="module">
    import pixelmatch from './scripts/pixelmatch.esm.js';
    window.pixelmatch = pixelmatch;
  </script>
  <script src="./scripts/ace.js"></script>
  <style>
    :root {
      --cell-size: 50px;
      --fill: hsl(142, 90%, 45%);
    }

    button {
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 10px 24px;
      font-size: 14px;
      font-weight: 500;
      color: #333;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      outline: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    button:hover {
      background: #fafafa;
      border-color: #d0d0d0;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
      transform: translateY(-1px);
    }

    button:active {
      background: #f5f5f5;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      transform: translateY(0);
    }

    button:focus-visible {
      border-color: #999;
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
    }

    button.upload-btn {
      background-color: #f0f0f0;
    }

    button.upload-btn:hover {
      background-color: #e0e0e0;
    }

    button.editor-btn {
      background-color: #f0f4f8;
    }

    button.editor-btn:hover {
      background-color: #e0e8f0;
    }

    #run-tests-icon {
      width: 12px;
      height: 12px;
      transition: all 0.2s ease;
      width: 0;
      height: 0;
      border-top: 6px solid transparent;
      border-bottom: 6px solid transparent;
      border-left: 10px solid #333;
    }

    #run-tests.running #run-tests-icon {
      width: 10px;
      height: 10px;
      border: none;
      background-color: #333;
    }

    input[type="checkbox"] {
      appearance: none;
      width: 16px;
      height: 16px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      z-index: 1;
      position: relative;
    }

    input[type="checkbox"]:hover {
      border-color: #d0d0d0;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    input[type="checkbox"]:checked {
      background: #383;
      border-color: #383;
    }

    input[type="checkbox"]:checked::after {
      content: "";
      position: absolute;
      left: 4px;
      top: 1px;
      width: 4px;
      height: 8px;
      border: solid white;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }

    input[type="checkbox"]:focus-visible {
      outline: none;
      border-color: #999;
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue",
        sans-serif;
    }

    .container {
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: start;
      gap: 20px;
    }

    .root-container {
      width: 100%;
      overflow: auto;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 20px;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #333;
    }

    #root {
      display: grid;
      width: fit-content;
      border: 1px solid #eee;
    }

    #root input[type="checkbox"] {
      z-index: 1;
    }

    #root .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .test-gallery {
      display: flex;
      overflow-x: auto;
      gap: 15px;
      padding: 10px;
      background: #f9f9f9;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      width: 100%;
      min-height: 180px;
      box-sizing: border-box;
    }

    .test-case-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #555;
    }

    .test-case-container span {
      padding: 4px 8px;
      border-radius: 4px;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .test-gallery img {
      height: 150px;
      border: 4px solid #ccc;
      border-radius: 4px;
      transition: border-color 0.3s ease, opacity 0.3s ease;
    }

    .test-gallery img.test-pending {
      border-color: #ffc107;
      animation: pulse 1.5s ease-in-out infinite;
    }

    img.test-pending+span {
      background-color: #ffc107;
      color: #333;
    }

    .test-gallery img.test-pass {
      border-color: #28a745;
    }

    .test-gallery .test-case-container img.test-selected {
      border-color: blue;
    }

    .test-case-container img.test-selected+span {
        background-color: blue;
        color: white;
    }

    img.test-pass+span {
      background-color: #28a745;
      color: white;
    }

    .test-gallery img.test-fail {
      border-color: #dc3545;
    }

    img.test-fail+span {
      background-color: #dc3545;
      color: white;
    }

    @keyframes pulse {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.4;
      }

      100% {
        opacity: 1;
      }
    }

    .diff-image {
      height: 150px;
      border: 2px dashed #dc3545;
      margin-top: 10px;
      border-radius: 4px;
      display: none;
    }

    .mask-image {
      height: 150px;
      border: 2px dashed #007bff;
      margin-top: 10px;
      border-radius: 4px;
      display: none;
    }

    .test-results, 
    .test-tools 
    {
      margin-top: -10px;
      padding: 10px 15px;
      font-size: 16px;
      font-weight: 500;
      background: #f4f4f4;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      width: 100%;
      box-sizing: border-box;
    }

    .test-tools {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    #modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      display: none;
    }

    #template-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 24px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      width: 90%;
      height: 90%;
      max-width: 600px;
      z-index: 1001;
      display: none;
      flex-direction: column;
      gap: 15px;
    }

    #template-modal h3 {
      margin: 0;
    }

    #modal-overlay.active,
    #template-modal.active {
      display: flex;
    }

    #template-editor {
      width: 100%;
      height: 90%;
      min-height: 200px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 8px;
      font-size: 14px;
    }

    #template-editor:focus {
      border-color: #007bff;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .svg-icon-16x16 {
      color: black;
      display: inline-block;
      width: 16px;
      height: 16px;
    }
  </style>
</head>

<body>
  <div class="container">
    <template id="cell">
      <style>
        #root {
          overflow: hidden;
        }

        .cell:has(input:checked) {
          border-radius: 50%;
          background-color: var(--fill);
        }

        .cell:has(input:checked).tl .tile-tl .s-tl,
        .cell:has(input:checked).tl .tile-tl .s-tr,
        .cell:has(input:checked).tl .tile-tl .s-bl,
        .cell:has(input:checked).tl .tile-tl .s-br {
          background-color: var(--fill);
        }

        .cell:has(input:checked).tr .tile-tl .s-tr,
        .cell:has(input:checked).tr .tile-tl .s-br,
        .cell:has(input:checked).tr .tile-tr .s-tl,
        .cell:has(input:checked).tr .tile-tr .s-bl {
          background-color: var(--fill);
        }

        .cell:has(input:checked).bl .tile-tl .s-br,
        .cell:has(input:checked).bl .tile-tl .s-bl,
        .cell:has(input:checked).bl .tile-bl .s-tr,
        .cell:has(input:checked).bl .tile-bl .s-tl {
          background-color: var(--fill);
        }

        .cell:has(input:checked).tr.bl.br .tile-tl .s-tl {
          background-color: var(--fill);
        }

        .cell:has(input:not(:checked)).tr.bl .tile-tl .s-tl,
        .cell:has(input:not(:checked)).tr.bl .tile-tl .s-tr,
        .cell:has(input:not(:checked)).tr.bl .tile-tl .s-bl,
        .cell:has(input:not(:checked)).tr.bl .tile-tl .s-br {
          background-color: var(--fill);
        }

        .cell {
          position: relative;
        }

        .tile {
          position: absolute;
          width: 100%;
          height: 100%;
          overflow: hidden;
          display: flex;
          flex-wrap: wrap;
          z-index: -1;
        }

        .tile-tl {
          top: -50%;
          left: -50%;
        }

        .tile-tr {
          top: -50%;
          right: -50%;
        }

        .tile-bl {
          bottom: -50%;
          left: -50%;
        }

        .tile-br {
          bottom: -50%;
          right: -50%;
        }

        .q {
          position: absolute;
          border-radius: 50%;
          width: 100%;
          height: 100%;
          background-color: white;
        }

        .s {
          width: 50%;
          height: 50%;
        }

        .q-tl {
          top: -50%;
          left: -50%;
        }

        .q-tr {
          top: -50%;
          right: -50%;
        }

        .q-bl {
          bottom: -50%;
          left: -50%;
        }

        .q-br {
          bottom: -50%;
          right: -50%;
        }
      </style>
      <div class="tile tile-tl">
        <div class="s s-tl"></div>
        <div class="q q-tl"></div>
        <div class="s s-tr"></div>
        <div class="q q-tr"></div>
        <div class="s s-bl"></div>
        <div class="q q-bl"></div>
        <div class="s s-br"></div>
        <div class="q q-br"></div>
      </div>
      <div class="tile tile-tr">
        <div class="s s-tl"></div>
        <div class="q q-tl"></div>
        <div class="s s-tr"></div>
        <div class="q q-tr"></div>
        <div class="s s-bl"></div>
        <div class="q q-bl"></div>
        <div class="s s-br"></div>
        <div class="q q-br"></div>
      </div>
      <div class="tile tile-bl">
        <div class="s s-tl"></div>
        <div class="q q-tl"></div>
        <div class="s s-tr"></div>
        <div class="q q-tr"></div>
        <div class="s s-bl"></div>
        <div class="q q-bl"></div>
        <div class="s s-br"></div>
        <div class="q q-br"></div>
      </div>
      <div class="tile tile-br">
        <div class="s s-tl"></div>
        <div class="q q-tl"></div>
        <div class="s s-tr"></div>
        <div class="q q-tr"></div>
        <div class="s s-bl"></div>
        <div class="q q-bl"></div>
        <div class="s s-br"></div>
        <div class="q q-br"></div>
      </div>
    </template>

    <div class="controls">
      <div class="slider-container">
        <label for="size-slider">–†–∞–∑–º–µ—Ä:</label>
        <input type="range" id="size-slider" min="50" max="200" value="50" />
      </div>

      <button id="run-tests">
        <span id="run-tests-icon"></span>
        <span id="run-tests-text">–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤</span>
      </button>
    </div>

    <div id="test-gallery" class="test-gallery">
      <p>–ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ—Å—Ç–æ–≤...</p>
    </div>

    <div id="test-results" class="test-results">
      –ó–∞–≥—Ä—É–∑–∫–∞...
    </div>

    <div id="test-tools" class="test-tools">
      <button id="randomize">
        <span class="svg-icon-16x16">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"
            class="size-6">
            <path stroke-linecap="round" stroke-linejoin="round"
              d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456ZM16.894 20.567 16.5 21.75l-.394-1.183a2.25 2.25 0 0 0-1.423-1.423L13.5 18.75l1.183-.394a2.25 2.25 0 0 0 1.423-1.423l.394-1.183.394 1.183a2.25 2.25 0 0 0 1.423 1.423l1.183.394-1.183.394a2.25 2.25 0 0 0-1.423 1.423Z" />
          </svg>
        </span>
        –†–∞–Ω–¥–æ–º
      </button>
      <button id="screenshot">
        <span class="svg-icon-16x16">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"
            class="size-6">
            <path stroke-linecap="round" stroke-linejoin="round"
              d="M6.827 6.175A2.31 2.31 0 0 1 5.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 0 0-1.134-.175 2.31 2.31 0 0 1-1.64-1.055l-.822-1.316a2.192 2.192 0 0 0-1.736-1.039 48.774 48.774 0 0 0-5.232 0 2.192 2.192 0 0 0-1.736 1.039l-.821 1.316Z" />
            <path stroke-linecap="round" stroke-linejoin="round"
              d="M16.5 12.75a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0ZM18.75 10.5h.008v.008h-.008V10.5Z" />
          </svg>
        </span>
        –°–∫—Ä–∏–Ω—à–æ—Ç –ø–æ–ª—è</button>
      <button id="open-template-editor" class="editor-btn">
        <span class="svg-icon-16x16">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"
            class="size-6">
            <path stroke-linecap="round" stroke-linejoin="round"
              d="M17.25 6.75 22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3-4.5 16.5" />
          </svg>
        </span>
        –†–µ–¥–∞–∫—Ç–æ—Ä —à–∞–±–ª–æ–Ω–∞
      </button>
      <button id="upload-test" class="upload-btn">
        <span class="svg-icon-16x16">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"
            class="size-6">
            <path stroke-linecap="round" stroke-linejoin="round"
              d="M9.75 3.104v5.714a2.25 2.25 0 0 1-.659 1.591L5 14.5M9.75 3.104c-.251.023-.501.05-.75.082m.75-.082a24.301 24.301 0 0 1 4.5 0m0 0v5.714c0 .597.237 1.17.659 1.591L19.8 15.3M14.25 3.104c.251.023.501.05.75.082M19.8 15.3l-1.57.393A9.065 9.065 0 0 1 12 15a9.065 9.065 0 0 0-6.23-.693L5 14.5m14.8.8 1.402 1.402c1.232 1.232.65 3.318-1.067 3.611A48.309 48.309 0 0 1 12 21c-2.773 0-5.491-.235-8.135-.687-1.718-.293-2.3-2.379-1.067-3.61L5 14.5" />
          </svg>
        </span>
        –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ç–µ—Å—Ç
      </button>
      <input type="file" id="image-upload-input" accept="image/*" style="display: none" />
    </div>

    <div class="root-container">
      <div id="root" data-cols="10" data-rows="10"></div>
    </div>
  </div>

  <div id="modal-overlay"></div>
  <div id="template-modal">
    <h3>–†–µ–¥–∞–∫—Ç–æ—Ä —à–∞–±–ª–æ–Ω–∞ —è—á–µ–π–∫–∏ (`&lt;template id="cell"&gt;`)</h3>
    <div id="template-editor"></div>
    <div class="modal-actions">
      <button id="cancel-template-edit" class="upload-btn">–û—Ç–º–µ–Ω–∞</button>
      <button id="apply-template">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
    </div>
  </div>

  <script>
    const randomizeButton = document.getElementById("randomize");
    const root = document.getElementById("root");
    const cols = Number(root.dataset.cols);
    const rows = Number(root.dataset.rows);
    root.style.gridTemplateColumns = `repeat(${cols + 1}, 1fr)`;
    const cellTemplate = document.getElementById("cell");
    const sizeSlider = document.getElementById("size-slider");
    const screenshotButton = document.getElementById("screenshot");
    const runTestsButton = document.getElementById("run-tests");
    const testGallery = document.getElementById("test-gallery");
    const uploadTestButton = document.getElementById("upload-test");
    const imageUploadInput = document.getElementById("image-upload-input");
    const testResults = document.getElementById("test-results");

    const modalOverlay = document.getElementById("modal-overlay");
    const templateModal = document.getElementById("template-modal");
    const applyTemplateButton = document.getElementById("apply-template");
    const cancelTemplateEditButton = document.getElementById("cancel-template-edit");
    const openTemplateEditorButton = document.getElementById("open-template-editor");

    const runTestsText = document.getElementById("run-tests-text");
    let isTestRunning = false;

    const aceEditor = ace.edit("template-editor");
    aceEditor.setTheme("ace/theme/github");
    aceEditor.session.setMode("ace/mode/html");
    aceEditor.setOptions({
      fontSize: "16px",
      useWorker: false,
    });

    let testImageUrls = [
      './test_images/test1.png',
      './test_images/test2.png',
      './test_images/test3.png',
      './test_images/test4.png',
      './test_images/test5.png',
      './test_images/test6.png',
      './test_images/test7.png',
      './test_images/test8.png',
      './test_images/test9.png',
      './test_images/test10.png',
      './test_images/test11.png',
      './test_images/test12.png',
      './test_images/test13.png',
    ];

    let testCases = [];

    function buildGrid() {
      root.innerHTML = "";
      for (let j = 0; j < rows + 1; j++) {
        for (let i = 0; i < cols + 1; i++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          cell.dataset.col = i;
          cell.dataset.row = j;
          cell.appendChild(document.importNode(cellTemplate.content, true));
          if (i !== cols && j !== rows) {
            const input = document.createElement("input");
            input.type = "checkbox";
            cell.appendChild(input);
          }
          root.appendChild(cell);
        }
      }
    }

    function openModal() {
      aceEditor.setValue(cellTemplate.innerHTML, 1);
      aceEditor.clearSelection();

      modalOverlay.classList.add("active");
      templateModal.classList.add("active");

      aceEditor.resize();
      aceEditor.focus();
    }

    function closeModal() {
      modalOverlay.classList.remove("active");
      templateModal.classList.remove("active");
    }
    openTemplateEditorButton.addEventListener("click", openModal);
    cancelTemplateEditButton.addEventListener("click", closeModal);
    modalOverlay.addEventListener("click", closeModal);

    applyTemplateButton.addEventListener("click", () => {
      cellTemplate.innerHTML = aceEditor.getValue();
      buildGrid();
      initializeTestGallery();
      closeModal();
    });

    function getCell(col, row) {
      return root.querySelector(`[data-col="${col}"][data-row="${row}"]`);
    }
    function isChecked(col, row) {
      const cell = getCell(col, row);
      if (!cell) return false;
      const checkbox = cell.querySelector('input[type="checkbox"]');
      return checkbox && checkbox.checked;
    }
    function updateTileClasses(col, row) {
      const tileCell = getCell(col, row);
      if (!tileCell || !tileCell.querySelector(".tile")) return;
      tileCell.classList.remove("tl", "tr", "bl", "br");
      if (isChecked(col - 1, row - 1)) tileCell.classList.add("tl");
      if (isChecked(col, row - 1)) tileCell.classList.add("tr");
      if (isChecked(col - 1, row)) tileCell.classList.add("bl");
      if (isChecked(col, row)) tileCell.classList.add("br");
    }
    function updateAllTiles() {
      for (let i = 0; i < cols + 1; i++) {
        for (let j = 0; j < rows + 1; j++) {
          updateTileClasses(i, j);
        }
      }
    }
    function randomize() {
      const checkboxes = root.querySelectorAll("input[type='checkbox']");
      checkboxes.forEach((checkbox) => {
        checkbox.checked = Math.random() > 0.5;
      });
      updateAllTiles();
    }
    function getCheckbox(col, row) {
      const cell = getCell(col, row);
      if (!cell) return null;
      return cell.querySelector('input[type="checkbox"]');
    }
    function setCheckboxState(col, row, state) {
      const checkbox = getCheckbox(col, row);
      if (checkbox) checkbox.checked = state;
    }
    function clearAllCheckboxes() {
      root
        .querySelectorAll("input[type='checkbox']")
        .forEach((checkbox) => (checkbox.checked = false));
    }
    async function takeSnapshot(element) {
      const canvas = await html2canvas(element, { scale: 1 });
      return canvas.toDataURL();
    }
    function delay(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function getImageDataFromSrc(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d", { willReadFrequently: true });
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          resolve({
            data: ctx.getImageData(0, 0, img.width, img.height),
            width: img.width,
            height: img.height,
          });
        };
        img.onerror = reject;
        img.src = src;
      });
    }
    async function loadAndParseTestFromUrl(url, index) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          try {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d", { willReadFrequently: true });
            canvas.width = img.width; canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const etalonImageSrc = canvas.toDataURL();
            const coords = parseImageForCoords(
              ctx, canvas.width, canvas.height
            );
            if (coords === null) {
              return reject(new Error(`–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${url}`));
            }
            resolve({
              id: `url-test-${index}`,
              name: `${url.split('/').pop()}`,
              coords: coords,
              etalonImageSrc: etalonImageSrc,
            });
          } catch (e) {
            reject(
              new Error(`–û—à–∏–±–∫–∞ canvas (–≤–æ–∑–º–æ–∂–Ω–æ CORS) –¥–ª—è: ${url}. –û—à–∏–±–∫–∞: ${e.message}`)
            );
          }
        };
        img.onerror = () => {
          reject(new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ${url}`));
        };
        img.src = url;
      });
    }

    async function initializeTestGallery() {
      testGallery.innerHTML = "<p>–ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ—Å—Ç–æ–≤ –∏–∑ URL...</p>";
      testResults.textContent = "–ó–∞–≥—Ä—É–∑–∫–∞...";
      let galleryHTML = "";
      document.documentElement.style.setProperty("--cell-size", "50px");
      sizeSlider.value = 50;

      testCases = [];

      clearAllCheckboxes();
      updateAllTiles();
      await delay(50);

      const emptyGridUrl = await takeSnapshot(root);
      if (!testImageUrls.length) {
        testImageUrls.push(emptyGridUrl);
      }

      const promises = testImageUrls.map((url, index) =>
        loadAndParseTestFromUrl(url, index)
      );

      try {
        testCases = await Promise.all(promises);
        if (testCases.length === 0) {
          testGallery.innerHTML = "<p>–ù–µ –Ω–∞–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤. –î–æ–±–∞–≤—å—Ç–µ URL –≤ –º–∞—Å—Å–∏–≤ testImageUrls.</p>";
          testResults.textContent = "‚ö†Ô∏è –¢–µ—Å—Ç—ã –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.";
          return;
        }
        testCases.forEach((testCase) => {
          galleryHTML += `
              <div class="test-case-container">
                <img id="${testCase.id}" src="${testCase.etalonImageSrc}" alt="${testCase.name}">
                <span>${testCase.name}</span>
                <img id="diff-${testCase.id}" class="diff-image" alt="Diff" style="display: none;">
                <img id="mask-${testCase.id}" class="mask-image" alt="Mask" style="display: none;">
              </div>
            `;
        });
        testGallery.innerHTML = galleryHTML;
        testResults.textContent = `üìä ${testCases.length} ${testCases.length === 1 ? '—Ç–µ—Å—Ç' : '—Ç–µ—Å—Ç–æ–≤'
          } –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –ì–æ—Ç–æ–≤–æ –∫ –∑–∞–ø—É—Å–∫—É.`;
      } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ç–µ—Å—Ç–æ–≤:", error);
        testGallery.innerHTML = `<p style="color: red;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–µ—Å—Ç–æ–≤: ${error.message}</p>`;
        testResults.textContent = "‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–µ—Å—Ç–æ–≤.";
      }
      clearField();
    }

    function clearStatuses() {
      const tests = document.querySelectorAll('.test-fail, .test-pass');
      Array.from(tests).forEach((el) => el.classList.remove('test-fail', 'test-pass'));
      const diff = Array.from(document.querySelectorAll('.diff-image')).filter((el) => el.style.display !== 'none');
      diff.forEach((el) => el.style.display = 'none');

      const masks = Array.from(document.querySelectorAll('.mask-image')).filter((el) => el.style.display !== 'none');
      masks.forEach((el) => el.style.display = 'none');
    }

    async function runAllTests() {
      let passedCount = 0;
      let failedCount = 0;
      testResults.textContent = `–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ ${testCases.length} —Ç–µ—Å—Ç–æ–≤... ‚è≥`;

      for (const testCase of testCases) {
        if (!isTestRunning) {
          testResults.textContent = `üö´ –¢–µ—Å—Ç—ã –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.`;
          break;
        }

        const imgElement = document.getElementById(testCase.id);
        const diffImgElement = document.getElementById(`diff-${testCase.id}`);
        const maskImgElement = document.getElementById(`mask-${testCase.id}`);

        if (!imgElement || !diffImgElement || !maskImgElement) continue;

        imgElement.classList.remove("test-pass", "test-fail", "test-selected");
        imgElement.classList.add("test-pending");
        diffImgElement.style.display = "none";
        diffImgElement.src = "";
        maskImgElement.style.display = "none";
        maskImgElement.src = "";

        imgElement.scrollIntoView({
          behavior: "smooth", block: "nearest", inline: "center",
        });

        clearAllCheckboxes();
        testCase.coords.forEach(([col, row]) =>
          setCheckboxState(col, row, true)
        );
        updateAllTiles();
        await delay(50);

        const currentImageDataUrl = await takeSnapshot(root);
        const etalonSrc = testCase.etalonImageSrc;

        try {
          const etalonImg = await getImageDataFromSrc(etalonSrc);
          const currentImg = await getImageDataFromSrc(currentImageDataUrl);

          if (
            etalonImg.width !== currentImg.width ||
            etalonImg.height !== currentImg.height
          ) {
            console.error("–û—à–∏–±–∫–∞ diff: –†–∞–∑–º–µ—Ä—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç!");
            imgElement.classList.replace("test-pending", "test-fail");
            failedCount++;
            continue;
          }

          const width = etalonImg.width;
          const height = etalonImg.height;

          const expectedSizeNoBorder = (cols + 1) * 50;
          let pixelOffset = (width === expectedSizeNoBorder) ? 0 : 1;
          const etalonCanvas = document.createElement("canvas");
          const etalonCtx = etalonCanvas.getContext("2d");
          etalonCanvas.width = width; etalonCanvas.height = height;
          etalonCtx.putImageData(etalonImg.data, 0, 0);
          const currentCanvas = document.createElement("canvas");
          const currentCtx = currentCanvas.getContext("2d");
          currentCanvas.width = width; currentCanvas.height = height;
          currentCtx.putImageData(currentImg.data, 0, 0);
          const maskWidth = 30;
          const maskStart = 10;

          for (let j = 0; j < rows; j++) {
            for (let i = 0; i < cols; i++) {
              const px = pixelOffset + i * 50 + maskStart;
              const py = pixelOffset + j * 50 + maskStart;
              etalonCtx.fillStyle = "white";
              etalonCtx.fillRect(px, py, maskWidth, maskWidth);
              currentCtx.fillStyle = "white";
              currentCtx.fillRect(px, py, maskWidth, maskWidth);
            }
          }
          const etalonData = etalonCtx.getImageData(0, 0, width, height);
          const currentData = currentCtx.getImageData(0, 0, width, height);

          const diffCanvas = document.createElement("canvas");
          diffCanvas.width = width; diffCanvas.height = height;
          const diffCtx = diffCanvas.getContext("2d");
          const diffImageData = diffCtx.createImageData(width, height);

          const numDiffPixels = pixelmatch(
            etalonData.data,
            currentData.data,
            diffImageData.data,
            width, height,
            {
              threshold: 0.1,
            }
          );

          if (numDiffPixels < 20) {
            imgElement.classList.replace("test-pending", "test-pass");
            passedCount++;
          } else {
            imgElement.classList.replace("test-pending", "test-fail");
            failedCount++;

            console.log(`–¢–µ—Å—Ç ${testCase.name} –£–ü–ê–õ: ${numDiffPixels} –ø–∏–∫—Å. –æ—Ç–ª–∏—á–∏–π. (–î–æ–ø—É—Å–∫: 20)`);

            diffCtx.putImageData(diffImageData, 0, 0);
            diffImgElement.src = diffCanvas.toDataURL();
            diffImgElement.style.display = "block";
            maskImgElement.src = currentCanvas.toDataURL();
            maskImgElement.style.display = "block";
          }
        } catch (error) {
          console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ diff-–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:", error);
          imgElement.classList.replace("test-pending", "test-fail");
          failedCount++;
        }
        await delay(500);
      }

      if (isTestRunning) {
        testResults.textContent = `‚úÖ –ü—Ä–æ–π–¥–µ–Ω–æ: ${passedCount} | ‚ùå –£–ø–∞–ª–æ: ${failedCount} | üìä –í—Å–µ–≥–æ: ${testCases.length}`;
      }

      isTestRunning = false;
      runTestsButton.classList.remove("running");
      runTestsText.textContent = "–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤";
    }

    runTestsButton.addEventListener("click", () => {
      if (isTestRunning) {
        isTestRunning = false;
        runTestsButton.classList.remove("running");
        runTestsText.textContent = "–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤";
      } else {
        if (sizeSlider.value !== "50") {
          alert(
            "–î–ª—è –∑–∞–ø—É—Å–∫–∞ —Ç–µ—Å—Ç–æ–≤ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–æ–ª–∑—É–Ω–æ–∫ '–†–∞–∑–º–µ—Ä' –≤ '50px' (–º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ)."
          );
          return;
        }

        clearStatuses();

        isTestRunning = true;
        runTestsButton.classList.add("running");
        runTestsText.textContent = "–°—Ç–æ–ø";
        runAllTests();
      }
    });


    function isPixelCheckboxGreen(ctx, x, y) {
      try {
        const pixelData = ctx.getImageData(x, y, 1, 1).data;
        const [r, g, b] = pixelData;
        const isGreenDominant = g > r && g > b;
        const isGreenBrightEnough = g > 100;
        const isGrayish = Math.abs(r - b) < 60;
        const isNotFillRed = r > 30;
        return isGreenDominant && isGreenBrightEnough && isGrayish && isNotFillRed;
      } catch (e) { return false; }
    }
    function parseImageForCoords(ctx, width, height) {
      const cellSize = 50; let pixelOffset = 0;
      const expectedSizeNoBorder = (cols + 1) * cellSize;
      const expectedSizeWithBorder = expectedSizeNoBorder + 2;
      if (width === expectedSizeWithBorder && height === expectedSizeWithBorder) {
        pixelOffset = 1;
      } else if (
        width !== expectedSizeNoBorder || height !== expectedSizeNoBorder
      ) {
        alert(`–û—à–∏–±–∫–∞: –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ ${width}x${height}px. –û–∂–∏–¥–∞–ª–æ—Å—å ${expectedSizeNoBorder}x${expectedSizeNoBorder}px –∏–ª–∏ ${expectedSizeWithBorder}x${expectedSizeWithBorder}px.`);
        return null;
      }
      const coords = []; const scanStart = 17; const scanEnd = 32;
      for (let j = 0; j < rows; j++) {
        for (let i = 0; i < cols; i++) {
          let isChecked = false;
          const absYBase = pixelOffset + j * cellSize;
          const absXBase = pixelOffset + i * cellSize;
          for (let y = scanStart; y <= scanEnd; y++) {
            if (isChecked) break;
            for (let x = scanStart; x <= scanEnd; x++) {
              const px = absXBase + x; const py = absYBase + y;
              if (isPixelCheckboxGreen(ctx, px, py)) {
                isChecked = true; break;
              }
            }
          }
          if (isChecked) { coords.push([i, j]); }
        }
      }
      return coords;
    }

    function handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (e) {
        processUploadedImage(e.target.result, file.name);
      };
      reader.readAsDataURL(file);
      event.target.value = null;
    }
    function processUploadedImage(imageDataUrl, filename) {
      const img = new Image();
      img.onload = async function () {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        canvas.width = img.width; canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        const parsedCoords = parseImageForCoords(
          ctx, canvas.width, canvas.height
        );
        if (!parsedCoords) return;
        document.documentElement.style.setProperty("--cell-size", "50px");
        sizeSlider.value = 50;
        clearAllCheckboxes();
        parsedCoords.forEach(([col, row]) =>
          setCheckboxState(col, row, true)
        );
        updateAllTiles();
        await delay(50);
        const newEtalonSrc = await takeSnapshot(root);
        const newTestCase = {
          id: `uploaded-${Date.now()}`,
          name: `(–ó–∞–≥—Ä—É–∂–µ–Ω) ${filename.substring(0, 20)}...`,
          coords: parsedCoords,
          etalonImageSrc: newEtalonSrc,
        };
        testCases.push(newTestCase);
        const newImageHTML = `
            <div class="test-case-container">
              <img id="${newTestCase.id}" src="${newTestCase.etalonImageSrc}" alt="${newTestCase.name}">
              <span>${newTestCase.name}</span>
              <img id="diff-${newTestCase.id}" class="diff-image" alt="Diff" style="display: none;">
              <img id="mask-${newTestCase.id}" class="mask-image" alt="Mask" style="display: none;" src="">
              </div>
          `;
        testGallery.insertAdjacentHTML("beforeend", newImageHTML);
        testResults.textContent = `üìä ${testCases.length} ${testCases.length === 1 ? '—Ç–µ—Å—Ç' : '—Ç–µ—Å—Ç–æ–≤'
          } –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –ì–æ—Ç–æ–≤–æ –∫ –∑–∞–ø—É—Å–∫—É.`;
        clearField();
      };
      img.src = imageDataUrl;
    }
    uploadTestButton.addEventListener("click", () => {
      imageUploadInput.click();
    });
    imageUploadInput.addEventListener("change", handleImageUpload);

    root.addEventListener("change", (e) => {
      if (e.target.type === "checkbox") updateAllTiles();
    });
    randomizeButton.addEventListener("click", () => {
      randomize();
    });
    sizeSlider.addEventListener("input", (e) => {
      const newSize = e.target.value + "px";
      document.documentElement.style.setProperty("--cell-size", newSize);
    });
    screenshotButton.addEventListener("click", () => {
      html2canvas(root, { scale: 1 }).then((canvas) => {
        const link = document.createElement("a");
        link.download = "marching-squares-screenshot.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
      });
    });

    function loadImageTestToField(imageDataUrl) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = async function () {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d", { willReadFrequently: true });
          canvas.width = img.width; canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          const parsedCoords = parseImageForCoords(
            ctx, canvas.width, canvas.height
          );
          if (!parsedCoords) return;
          document.documentElement.style.setProperty("--cell-size", "50px");
          sizeSlider.value = 50;
          clearAllCheckboxes();
          parsedCoords.forEach(([col, row]) =>
            setCheckboxState(col, row, true)
          );
          updateAllTiles();
          resolve();
        };
        img.src = imageDataUrl;
      });
    }

    testGallery.addEventListener('click', async (e) => {
      if (!isTestRunning && e.target.matches('img:first-of-type')) {
        Array.from(testGallery.querySelectorAll('.test-selected')).forEach((el) => el.classList.remove('test-selected'));
        e.target.classList.add('test-selected');
        await loadImageTestToField(e.target.src);
      }
    });

    function clearField() {
      clearAllCheckboxes();
      updateAllTiles();
    }

    buildGrid();
    initializeTestGallery();
  </script>
</body>

</html>